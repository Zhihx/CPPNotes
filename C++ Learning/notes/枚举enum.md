枚举的主要作用是增加程序的可读性，其最常见的应用是设置状态量。
## 不限定作用域的枚举类型

- 基本用法为
```c++
enum enumName
{
	enumList // 枚举成员列表，以逗号分割，末尾无分号，默认以0为起始
};
```
- 定义完枚举类型后，可以定义该枚举类型的变量，因此我们可以把[[枚举enum]]和[[关键字typename]]、[[对比using vs typedef]]、[[类Class]]、[[结构体Struct]]、[[联合体unions]]放在一起思考，这些操作都是在创建新类型（或指定类型的别名）。
- 枚举类型的变量定义可以与枚举类型一起定义，如
```c++
enum enumName
{
	enumList
} enumVar1, enumVar2;
```
- 枚举类型变量所占内存大小与整型相同，而[[联合体unions]]所占内存大小为成员所占内存大小的最大值。
- 可以通过[[作用域操作符]]访问枚举类型中的枚举成员，当然也可以直接访问枚举成员，因此要注意命名冲突的问题（此问题可以通过[[枚举enum#限定作用域的枚举类型]]来解决）。

## 限定作用域的枚举类型

前面我们已经提过，枚举类型中枚举成员可以直接访问，也可以通过作用域操作符来进行访问，这是因为默认的枚举类型是不限定作用域的。如果要限定作用域，则需使用：

```c++
#include <iostream>
enum class Example
{
	A, B, C
} e1;
int main()
{	
	e1 = Example::A; // 可以通过编译器
}
```
```c++
#include <iostream>
enum class Example
{
	A, B, C
} e1;
int main()
{	
	e1 = A; // 不可以通过编译器
}
```
可以看出，限定作用域的枚举类型是可以通过作用域来规避可能的命名冲突的问题的

## 需要注意的是

不管是限定作用域的枚举类型，还是不限定作用域的枚举类型，都不能隐式地将整型变量转换，必须进行显示的强制转换：
```c++
#include <iostream>
enum Example
{
	A, B, C
} e1;
int main()
{	
	e1 = static_cast<Example>(0);
	// e1 = 0; // 无法通过编译器
}
```